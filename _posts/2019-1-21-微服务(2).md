---
layout: post
title:  微服务基础(2)
date:   2019-1-21 00:00:00 +0800
categories: 微服务
tag: 微服务
---

* content
{:toc}


### 微服务数据库独立
   1. 在单体结构中所有业务都是使用一个数据库，但是随着业务的增加，所有表公用一个库，多表难以维护和管理，数据量增加导致查询速度变慢
   2. 微服务依据业务划分服务，每个服务运行在自己的进程中，而且每个服务都有自己独立的数据库，即使业务增加，只需要服务之间接口调用，不需要进行
      数据库集成。
   3. 数据库独立便于以后迁移数据库。如下图
   ![image](https://beautifulgirlzhangxiaogui.top/styles/images/2.png)

### 微服务自动化部署及管理
1. 微服务系统中，整个系统会被拆分为若干个服务，每个服务是一个独立运行的程序，单体系统只需要部署一次，而微服务有多少个服务就需要部署多少次
2. Docker容器部署微服务，Jenkins自动部署
3. 微服务需要进行集中化管理，SpringCloud的Eureka注册服务发现服务，Zookeeper、Consul等
4. 分布式系统是由集群部署的，由很多台服务器共同完成用户请求，分布式系统是通过网络协议进行通信的，因此分布式系统在哪部署都可以(不用区分地区和机房)。

### 解决微服务中的雪崩效应--熔断机制
1. 由于微服务是分布式架构，需要考虑服务的独立性和相互调用的可靠性，以及分布式事务、全局锁、全局ID。
2. 分布式系统集群化部署会给数据的一致性带来问题，由于服务与服务之间是通过通讯协议通信的，如果网络不好将会对系统产生影响。
3. 分布式系统中服务与服务之间相互依赖，如果出现网络延迟或者单个服务出现问题，在高并发的情况下就会导致线程阻塞，在极短的时间内该服务的线程资源就会消耗  完，最终导致该服务不能用，因为服之间是依赖的，因此导致整个系统不可用，这就是雪崩效应。
4. 为防止雪崩效应、采用熔断机制

### 熔断机制
   举个栗子，例如在微服务系统中，存在abcdefgh等多个服务，用户的请求通过网关后，再到具体服务，服务之间相互依赖，例如服务b依赖服务f，一个对外暴露的接口api需要服务b、f相互协同才能完成工作，如下图。
   ![image](https://beautifulgirlzhangxiaogui.top/styles/images/4.png)
   * 假设服务b出现故障或者网络出现延迟，而且此时处于高并发状态，服务b就会出现大量的线程阻塞，有可能在很短时间内线程资源就会被消耗完，进而导致服务b不可用。
   * 如果服务b为较底层服务，或者与b服务相互依赖的服务很多，进而影响到其他服务，导致其他服务会一直等待服务b，如果服务b很长时间不进行处理，大量网络请求堆积在服务b和与服务b相互依赖的其他服务，所有服务b出现故障导致依赖于服务b的服务出现故障，进而导致整个系统不可用。由于服务运行商和网络服务商的不可靠导致服务的不可靠，又故障的传播性，导致大量服务不可用，最终系统崩溃。
   * 因此出现的熔断机制：当服务b出现故障，请求失败次数超过设定阈值，服务b就会启动熔断器，之后服务b不进行任何逻辑操作，快速执行失败，直接返回请求失败的信息，依赖于服务b的其他服务也不会因为得不到响应而出现线程阻塞。此时只有服务b和依赖服务b的其他服务不可用，其他服务正常运行，如下图。
   ![image](https://beautifulgirlzhangxiaogui.top/styles/images/5.png)
   * 熔断器还有另外一个机制，就是自我修复机制。当服务b熔断后，一段时间后，半打开熔断器，半打开的熔断器会检查部分请求是否正常，其他的请求快速执行失败，检查的请求如果响应成功，则可以判断服务b可以使用进而关闭熔断器，如果服务b不正常，继续打开熔断器。
   * 熔断器提供了很多监控，服务器是否可用、熔断器是否打开、目前的吞吐量、网络延迟状态。
   
### 微服务优劣势
优势:</br>
1. 复杂业务拆分若干小业务，每个业务拆分成一个服务，服务与服务之间边界化明显；复杂的问题简单化，服务和编码按照业务拆分，代码扩展性和可读性增强。
2. 微服务为分布式系统，服务与服务之间耦合度为零，业务增加时，可根据具体情况进行拆分；并发量增加时可以将服务集群化部署，增强负载能力，每个微服务单元具有很强横向扩展性。
3. 服务之间通过http通信，单个服务内部高度耦合，服务与服务之间完全独立，无耦合，使得一个微服务系统中的各个微服务单元可以采用任何编程语言和技术实现，不必统一编程语言和统一技术，只要通信完好就好。
4. 微服务的每个服务单元都是独立部署运行在自己的进程中，单个服务的修改和部署不影响其他服务单元。如果是单体结构如ssm，一个模块修改，需要测试部署整个应用。其实就是减少测试部署时间，你改的同时，系统照常运行（这里是没有依赖的服务）。
5. 高可用和分区容错，说白了高可用就是系统7*24小时不间断服务，你给我请求我就给你响应。分区容错指的是系统不会因为一个服务器或多个服务器罢工了影响其他正常服务器运行。

劣势:</br>
1. 微服务复杂度，需要将多个业务进行拆分、服务之间的http协议通信或者消息通信，需要选择最佳通信方式解决网络服务差的情况下带来的风险，服务之间依赖度高，修改一个服务会影响依赖他的服务，服务的依赖性导致测试麻烦
2. 分布式事务：微服务系统中每个服务都是独立的进程单元，每个服务都有独立的数据库。通常情况下，关系型数据库支持事务（特定数据引擎下），如mongdb不支持事务的，因此微服务中关于事务处理采用的方法是两阶段提交。
* 举个栗子：在狗东上买一部iPhone，你的账户减少1000，手机库存数减1，卖家账户加1000，单体应用且支持事务的mysql（InnoDB数据引擎支持事务）；哪代码如下
```
@Transactional
public void update() throws Exeption(){
   updateAccountTable();//更新账户表
   updateGoodsTable();//更新商品表
}
```
* 再举个栗子：如果在微服务系统中，每个服务都是独立的，账户和商品都是不同的服务，因为两张表不在同一个数据库，因此不能采用数据库自带事务功能。于是就要两阶段提交。
```
第一阶段：service-account发起一个分布式事务，交个事务协调器TC进行处理，事务协调器TC向所有参与的事务节点发出处理事务操作的准备操作。所有的参与节点执行准备操作，将Undo和Redo信息写入日志，并向事务管理器返回准备操作是否成功。
第二阶段：事务管理器收集所有节点的准备操作是否成功，如果都成功，就通知所有的节点执行提交操作，如果有一个失败，就进行回滚。
```
![image](https://beautifulgirlzhangxiaogui.top/styles/images/6.png) 
注：两阶段提交即使第一阶段全成功，但是只要第二阶段有一个节点不成功，就会导致数据不准确。这时就需要人工去排查，如果分布式事务涉及节点多，某一个节点的网络出现问题都会导致整个分布式事务堵塞，因此不推荐使用分布式事务。
